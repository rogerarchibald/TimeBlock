
Builds/main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  00000610  000006a4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000610  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000f  00800112  00800112  000006b6  2**0
                  ALLOC
  3 .stab         00001f38  00000000  00000000  000006b8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000016cc  00000000  00000000  000025f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00003cbc  2**0
                  CONTENTS, READONLY
  6 .debug_info   000005f4  00000000  00000000  00003ccd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000005a2  00000000  00000000  000042c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000001d  00000000  00000000  00004863  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000208  00000000  00000000  00004880  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 99 00 	jmp	0x132	; 0x132 <__vector_3>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__vector_14>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e0 e1       	ldi	r30, 0x10	; 16
  7c:	f6 e0       	ldi	r31, 0x06	; 6
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a2 31       	cpi	r26, 0x12	; 18
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	11 e0       	ldi	r17, 0x01	; 1
  8c:	a2 e1       	ldi	r26, 0x12	; 18
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a1 32       	cpi	r26, 0x21	; 33
  96:	b1 07       	cpc	r27, r17
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 78 02 	call	0x4f0	; 0x4f0 <main>
  9e:	0c 94 06 03 	jmp	0x60c	; 0x60c <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <init_ADC>:




void init_ADC(void){
ADMUX = 0xC7;	//C is to select the internal 1.1V reference, 7 selects the input
  a6:	87 ec       	ldi	r24, 0xC7	; 199
  a8:	80 93 7c 00 	sts	0x007C, r24
ADCSRA = 0x06;	//set prescaler to /64
  ac:	86 e0       	ldi	r24, 0x06	; 6
  ae:	80 93 7a 00 	sts	0x007A, r24
  b2:	08 95       	ret

000000b4 <read_ADC>:



uint16_t read_ADC (void){
	uint32_t voltval = 0;
	PORTC |= 0x10;	//turn on divider return FET
  b4:	44 9a       	sbi	0x08, 4	; 8
	PORTD = 0;	//turn off all BJT's so that in the next line this delay of 60mS doesn't look like a glitch on display
  b6:	1b b8       	out	0x0b, r1	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  b8:	8f e5       	ldi	r24, 0x5F	; 95
  ba:	9a ee       	ldi	r25, 0xEA	; 234
  bc:	01 97       	sbiw	r24, 0x01	; 1
  be:	f1 f7       	brne	.-4      	; 0xbc <read_ADC+0x8>
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <read_ADC+0xe>
  c2:	00 00       	nop
	_delay_ms(60);	//discharge the filter cap down to the divider level (25mS seems about right, 30 is a buffer)
	ADCSRA |= 0x10;	//clear interrupt flag before starting a conversion
  c4:	80 91 7a 00 	lds	r24, 0x007A
  c8:	80 61       	ori	r24, 0x10	; 16
  ca:	80 93 7a 00 	sts	0x007A, r24
	ADCSRA |= 0xC0; //enable ADC and start conversion
  ce:	80 91 7a 00 	lds	r24, 0x007A
  d2:	80 6c       	ori	r24, 0xC0	; 192
  d4:	80 93 7a 00 	sts	0x007A, r24
	while(!(ADCSRA & 0x10)){}	//kill time while waiting for conversion to end
  d8:	80 91 7a 00 	lds	r24, 0x007A
  dc:	84 ff       	sbrs	r24, 4
  de:	fc cf       	rjmp	.-8      	; 0xd8 <read_ADC+0x24>
	PORTC &= ~(0x10);	//kill the FET to conserve battery
  e0:	44 98       	cbi	0x08, 4	; 8
	voltval |= ADCL;
  e2:	80 91 78 00 	lds	r24, 0x0078
	voltval |= (ADCH << 8);
  e6:	20 91 79 00 	lds	r18, 0x0079
  ea:	30 e0       	ldi	r19, 0x00	; 0
  ec:	32 2f       	mov	r19, r18
  ee:	22 27       	eor	r18, r18
  f0:	a9 01       	movw	r20, r18
  f2:	66 27       	eor	r22, r22
  f4:	57 fd       	sbrc	r21, 7
  f6:	60 95       	com	r22
  f8:	76 2f       	mov	r23, r22
  fa:	9a 01       	movw	r18, r20
  fc:	ab 01       	movw	r20, r22
  fe:	28 2b       	or	r18, r24
	voltval *= 322;	//convert ADC value to hundreds of mV when we're running a /3 divider
 100:	a2 e4       	ldi	r26, 0x42	; 66
 102:	b1 e0       	ldi	r27, 0x01	; 1
 104:	0e 94 a0 02 	call	0x540	; 0x540 <__muluhisi3>
	voltval /= 100;	//convert ADC value to mV
 108:	24 e6       	ldi	r18, 0x64	; 100
 10a:	30 e0       	ldi	r19, 0x00	; 0
 10c:	40 e0       	ldi	r20, 0x00	; 0
 10e:	50 e0       	ldi	r21, 0x00	; 0
 110:	0e 94 bf 02 	call	0x57e	; 0x57e <__udivmodsi4>
	
	return voltval;	
	
	
 114:	c9 01       	movw	r24, r18
 116:	08 95       	ret

00000118 <set_intensity>:



//update the intensity value stored in address 10 of EEPROM
void set_intensity(u8 newintensity){
    eeprom_write_byte ((uint8_t*)10, newintensity);
 118:	68 2f       	mov	r22, r24
 11a:	8a e0       	ldi	r24, 0x0A	; 10
 11c:	90 e0       	ldi	r25, 0x00	; 0
 11e:	0c 94 f8 02 	jmp	0x5f0	; 0x5f0 <__eewr_byte_m328p>

00000122 <get_intensity>:
}


//read back the intensity stored in address 10 of EEPROM, ensure it's no greater than 9 and return it.
u8 get_intensity(void){
u8 tempintense = eeprom_read_byte((uint8_t*)10); //read byte 10 of EEPROM, which is where I'll store the intensity
 122:	8a e0       	ldi	r24, 0x0A	; 10
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <__eerd_byte_m328p>
 12a:	8a 30       	cpi	r24, 0x0A	; 10
 12c:	08 f0       	brcs	.+2      	; 0x130 <get_intensity+0xe>
 12e:	89 e0       	ldi	r24, 0x09	; 9
    if(tempintense > 9){
        tempintense = 9;
    }

    return tempintense;
 130:	08 95       	ret

00000132 <__vector_3>:

volatile u8 gotosleep = 0;


//servicing the ISR for button press PCINT0 to wake things up, nothing to do here.
ISR(PCINT0_vect){
 132:	1f 92       	push	r1
 134:	0f 92       	push	r0
 136:	0f b6       	in	r0, 0x3f	; 63
 138:	0f 92       	push	r0
 13a:	11 24       	eor	r1, r1
 13c:	8f 93       	push	r24
 13e:	9f 93       	push	r25
	asm ("nop");
 140:	00 00       	nop
	tog_tp1
 142:	95 b1       	in	r25, 0x05	; 5
 144:	82 e0       	ldi	r24, 0x02	; 2
 146:	89 27       	eor	r24, r25
 148:	85 b9       	out	0x05, r24	; 5
}
 14a:	9f 91       	pop	r25
 14c:	8f 91       	pop	r24
 14e:	0f 90       	pop	r0
 150:	0f be       	out	0x3f, r0	; 63
 152:	0f 90       	pop	r0
 154:	1f 90       	pop	r1
 156:	18 95       	reti

00000158 <setsleepstat>:

}	//end of main


void setsleepstat (u8 newstat){
	gotosleep = newstat;
 158:	80 93 12 01 	sts	0x0112, r24
 15c:	08 95       	ret

0000015e <timer0Init>:
static u16 cyclesinstat = 0;	//how many cycles have I been in this status


//initialize timer0 with a 200uS rollover to trigger an ISR
void timer0Init(void){
    OCR0A = timerroll;   //timerroll is defined in DOC_head.h depending on clock frequency
 15e:	83 e6       	ldi	r24, 0x63	; 99
 160:	87 bd       	out	0x27, r24	; 39
    TCCR0A = 0x02;  //set WGM for CTC mode with OCR0A as top
 162:	82 e0       	ldi	r24, 0x02	; 2
 164:	84 bd       	out	0x24, r24	; 36
    TCCR0B = 0x02;  //set CS1 for /8 prescaler
 166:	85 bd       	out	0x25, r24	; 37
    TIFR0 |= 0x02;  //clear the OCF0A overflow flag
 168:	a9 9a       	sbi	0x15, 1	; 21
    TIMSK0 |= 0x02; //Enable interrupts from Timer0 OverflowA
 16a:	ee e6       	ldi	r30, 0x6E	; 110
 16c:	f0 e0       	ldi	r31, 0x00	; 0
 16e:	80 81       	ld	r24, Z
 170:	82 60       	ori	r24, 0x02	; 2
 172:	80 83       	st	Z, r24
 174:	08 95       	ret

00000176 <initialize_intensity>:
    
}

//called from main prior to initializing timer.  'intense' will be grabbed based on what's stored in EEPROM.
void initialize_intensity (u8 intense){
    intensity = intense;
 176:	80 93 19 01 	sts	0x0119, r24
 17a:	08 95       	ret

0000017c <next_digit>:
}	//end of ISR



//this function will cycle the anodes of the diodes and turn the appropriate anode on (turning it off is accomplished in teh Timer0 overflow ISR dependant on intensity value
void next_digit(void){
 17c:	cf 93       	push	r28
 17e:	df 93       	push	r29
 180:	00 d0       	rcall	.+0      	; 0x182 <next_digit+0x6>
 182:	00 d0       	rcall	.+0      	; 0x184 <next_digit+0x8>
 184:	cd b7       	in	r28, 0x3d	; 61
 186:	de b7       	in	r29, 0x3e	; 62
    static u8 placeholder = 0;  //will cycle from 0-3 and repeat.  Will determine which of the 4 P-ch FETS for the anodes is active.
	u8 dig_array[] = {0x04, 0x02, 0x01, 0x08};  //array to cycle through the different anodes
 188:	84 e0       	ldi	r24, 0x04	; 4
 18a:	89 83       	std	Y+1, r24	; 0x01
 18c:	82 e0       	ldi	r24, 0x02	; 2
 18e:	8a 83       	std	Y+2, r24	; 0x02
 190:	81 e0       	ldi	r24, 0x01	; 1
 192:	8b 83       	std	Y+3, r24	; 0x03
 194:	88 e0       	ldi	r24, 0x08	; 8
 196:	8c 83       	std	Y+4, r24	; 0x04
    placeholder ++;
 198:	80 91 13 01 	lds	r24, 0x0113
 19c:	8f 5f       	subi	r24, 0xFF	; 255
    if(placeholder >= 4){
 19e:	84 30       	cpi	r24, 0x04	; 4
 1a0:	18 f4       	brcc	.+6      	; 0x1a8 <next_digit+0x2c>

//this function will cycle the anodes of the diodes and turn the appropriate anode on (turning it off is accomplished in teh Timer0 overflow ISR dependant on intensity value
void next_digit(void){
    static u8 placeholder = 0;  //will cycle from 0-3 and repeat.  Will determine which of the 4 P-ch FETS for the anodes is active.
	u8 dig_array[] = {0x04, 0x02, 0x01, 0x08};  //array to cycle through the different anodes
    placeholder ++;
 1a2:	80 93 13 01 	sts	0x0113, r24
 1a6:	02 c0       	rjmp	.+4      	; 0x1ac <next_digit+0x30>
    if(placeholder >= 4){
        placeholder = 0;
 1a8:	10 92 13 01 	sts	0x0113, r1
    }
    PORTD = numbers[digits[placeholder]];   //set up bjts on cathodes.
 1ac:	e0 91 13 01 	lds	r30, 0x0113
 1b0:	f0 e0       	ldi	r31, 0x00	; 0
 1b2:	e3 5e       	subi	r30, 0xE3	; 227
 1b4:	fe 4f       	sbci	r31, 0xFE	; 254
 1b6:	e0 81       	ld	r30, Z
 1b8:	f0 e0       	ldi	r31, 0x00	; 0
 1ba:	ee 5f       	subi	r30, 0xFE	; 254
 1bc:	fe 4f       	sbci	r31, 0xFE	; 254
 1be:	80 81       	ld	r24, Z
 1c0:	8b b9       	out	0x0b, r24	; 11
	
	
 switch (clockstat){	//this switch will determine the colon/decimal place
 1c2:	80 91 01 01 	lds	r24, 0x0101
 1c6:	81 30       	cpi	r24, 0x01	; 1
 1c8:	19 f0       	breq	.+6      	; 0x1d0 <next_digit+0x54>
 1ca:	83 30       	cpi	r24, 0x03	; 3
 1cc:	31 f0       	breq	.+12     	; 0x1da <next_digit+0x5e>
 1ce:	0a c0       	rjmp	.+20     	; 0x1e4 <next_digit+0x68>
	 case clockrun:
		if(digits[0] & 0x01){  //if we've got an odd number
 1d0:	80 91 1d 01 	lds	r24, 0x011D
 1d4:	80 ff       	sbrs	r24, 0
 1d6:	06 c0       	rjmp	.+12     	; 0x1e4 <next_digit+0x68>
 1d8:	04 c0       	rjmp	.+8      	; 0x1e2 <next_digit+0x66>
		}	//set the colon when we have an odd number
		
		break;
		
		case voltdisp:
		if (placeholder == 2){  //while displaying the voltage, set the lower dot of hte colon to be a cedimal point
 1da:	80 91 13 01 	lds	r24, 0x0113
 1de:	82 30       	cpi	r24, 0x02	; 2
 1e0:	09 f4       	brne	.+2      	; 0x1e4 <next_digit+0x68>
			PORTD |= 0x08;
 1e2:	5b 9a       	sbi	0x0b, 3	; 11
		}
		break;
		
	}	//end of switch

    PORTC &= ~(dig_array[placeholder]);    //enable the appropriate anode by clearing the Gate of the P-ch FET.
 1e4:	98 b1       	in	r25, 0x08	; 8
 1e6:	80 91 13 01 	lds	r24, 0x0113
 1ea:	fe 01       	movw	r30, r28
 1ec:	e8 0f       	add	r30, r24
 1ee:	f1 1d       	adc	r31, r1
 1f0:	81 81       	ldd	r24, Z+1	; 0x01
 1f2:	80 95       	com	r24
 1f4:	89 23       	and	r24, r25
 1f6:	88 b9       	out	0x08, r24	; 8

}   //end of next_digit function
 1f8:	0f 90       	pop	r0
 1fa:	0f 90       	pop	r0
 1fc:	0f 90       	pop	r0
 1fe:	0f 90       	pop	r0
 200:	df 91       	pop	r29
 202:	cf 91       	pop	r28
 204:	08 95       	ret

00000206 <inc_seconds>:


//function to actually increment the time.
void inc_seconds(void){
	
    digits[0] ++;
 206:	80 91 1d 01 	lds	r24, 0x011D
 20a:	8f 5f       	subi	r24, 0xFF	; 255
    if(digits[0] >= 10){
 20c:	8a 30       	cpi	r24, 0x0A	; 10
 20e:	18 f4       	brcc	.+6      	; 0x216 <inc_seconds+0x10>


//function to actually increment the time.
void inc_seconds(void){
	
    digits[0] ++;
 210:	80 93 1d 01 	sts	0x011D, r24
 214:	07 c0       	rjmp	.+14     	; 0x224 <inc_seconds+0x1e>
    if(digits[0] >= 10){
        digits[0] = 0;
 216:	10 92 1d 01 	sts	0x011D, r1
        digits[1]++;
 21a:	80 91 1e 01 	lds	r24, 0x011E
 21e:	8f 5f       	subi	r24, 0xFF	; 255
 220:	80 93 1e 01 	sts	0x011E, r24
    }
    if(digits[1] >= 6){
 224:	80 91 1e 01 	lds	r24, 0x011E
 228:	86 30       	cpi	r24, 0x06	; 6
 22a:	38 f0       	brcs	.+14     	; 0x23a <inc_seconds+0x34>
        digits[1] = 0;
 22c:	10 92 1e 01 	sts	0x011E, r1
         digits[2]++;
 230:	80 91 1f 01 	lds	r24, 0x011F
 234:	8f 5f       	subi	r24, 0xFF	; 255
 236:	80 93 1f 01 	sts	0x011F, r24
    }
    if(digits[2] >= 10){
 23a:	80 91 1f 01 	lds	r24, 0x011F
 23e:	8a 30       	cpi	r24, 0x0A	; 10
 240:	38 f0       	brcs	.+14     	; 0x250 <inc_seconds+0x4a>
        digits[2] = 0;
 242:	10 92 1f 01 	sts	0x011F, r1
        digits[3] ++;
 246:	80 91 20 01 	lds	r24, 0x0120
 24a:	8f 5f       	subi	r24, 0xFF	; 255
 24c:	80 93 20 01 	sts	0x0120, r24
    }
    if(digits[3] >= 10){
 250:	80 91 20 01 	lds	r24, 0x0120
 254:	8a 30       	cpi	r24, 0x0A	; 10
 256:	28 f0       	brcs	.+10     	; 0x262 <inc_seconds+0x5c>
        digits[3] = 0;
 258:	10 92 20 01 	sts	0x0120, r1
        setsleepstat(1);   //this will set a flag in a function in main.c to initiate shutting it down...if we roll all the way over, shut r down
 25c:	81 e0       	ldi	r24, 0x01	; 1
 25e:	0c 94 ac 00 	jmp	0x158	; 0x158 <setsleepstat>
 262:	08 95       	ret

00000264 <timeequals0>:



void timeequals0 (void){
	for(int i = 0; i < 4; i++){
		digits[i] = 0;
 264:	ed e1       	ldi	r30, 0x1D	; 29
 266:	f1 e0       	ldi	r31, 0x01	; 1
 268:	10 82       	st	Z, r1
 26a:	11 82       	std	Z+1, r1	; 0x01
 26c:	12 82       	std	Z+2, r1	; 0x02
 26e:	13 82       	std	Z+3, r1	; 0x03
 270:	08 95       	ret

00000272 <shut_r_down>:
}



void shut_r_down(void){
	timeequals0();
 272:	0e 94 32 01 	call	0x264	; 0x264 <timeequals0>
	TCCR0B = 0;		//kill timer
 276:	15 bc       	out	0x25, r1	; 37
	PORTD = 0;		//turn off NPNs
 278:	1b b8       	out	0x0b, r1	; 11
	PORTC |= 0x0F;	//turn off P-ch
 27a:	88 b1       	in	r24, 0x08	; 8
 27c:	8f 60       	ori	r24, 0x0F	; 15
 27e:	88 b9       	out	0x08, r24	; 8
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);	//going to deep sleep
 280:	83 b7       	in	r24, 0x33	; 51
 282:	81 7f       	andi	r24, 0xF1	; 241
 284:	84 60       	ori	r24, 0x04	; 4
 286:	83 bf       	out	0x33, r24	; 51
	PCIFR |= 0x01;	//clear interrupt flag
 288:	d8 9a       	sbi	0x1b, 0	; 27
	PCICR |= 0x01;	//enable Pin Change Interrupt
 28a:	e8 e6       	ldi	r30, 0x68	; 104
 28c:	f0 e0       	ldi	r31, 0x00	; 0
 28e:	80 81       	ld	r24, Z
 290:	81 60       	ori	r24, 0x01	; 1
 292:	80 83       	st	Z, r24
	sleep_mode();
 294:	83 b7       	in	r24, 0x33	; 51
 296:	81 60       	ori	r24, 0x01	; 1
 298:	83 bf       	out	0x33, r24	; 51
 29a:	88 95       	sleep
 29c:	83 b7       	in	r24, 0x33	; 51
 29e:	8e 7f       	andi	r24, 0xFE	; 254
 2a0:	83 bf       	out	0x33, r24	; 51
	asm ("nop");
 2a2:	00 00       	nop
	PCICR = 0;	//disable PC Interrupt
 2a4:	10 82       	st	Z, r1
	set_sleep_mode(SLEEP_MODE_IDLE);	//change back to IDLE
 2a6:	83 b7       	in	r24, 0x33	; 51
 2a8:	81 7f       	andi	r24, 0xF1	; 241
 2aa:	83 bf       	out	0x33, r24	; 51
	clockstat = clockrun;	//arming for post-reset
 2ac:	81 e0       	ldi	r24, 0x01	; 1
 2ae:	80 93 01 01 	sts	0x0101, r24
	fallarm = 0;
 2b2:	10 92 1a 01 	sts	0x011A, r1
	turnoff_arm = 1;
 2b6:	80 93 00 01 	sts	0x0100, r24
	cyclesinstat = 0;
 2ba:	10 92 18 01 	sts	0x0118, r1
 2be:	10 92 17 01 	sts	0x0117, r1
	setsleepstat(0);
 2c2:	80 e0       	ldi	r24, 0x00	; 0
 2c4:	0e 94 ac 00 	call	0x158	; 0x158 <setsleepstat>
	TCCR0B |= 0x02;	//re-enable clock
 2c8:	85 b5       	in	r24, 0x25	; 37
 2ca:	82 60       	ori	r24, 0x02	; 2
 2cc:	85 bd       	out	0x25, r24	; 37
 2ce:	08 95       	ret

000002d0 <display_batt>:
}

//this just puts 'batt' across the display.  Will be called for 1 second prior to displaying the actual voltage.  index points 11-14 of digits are the characters to write 'batt'
void display_batt(void){
		for (int i = 11; i < 15; i ++){
			digits[(i-11)] = i;
 2d0:	ed e1       	ldi	r30, 0x1D	; 29
 2d2:	f1 e0       	ldi	r31, 0x01	; 1
 2d4:	8b e0       	ldi	r24, 0x0B	; 11
 2d6:	80 83       	st	Z, r24
 2d8:	8c e0       	ldi	r24, 0x0C	; 12
 2da:	81 83       	std	Z+1, r24	; 0x01
 2dc:	8d e0       	ldi	r24, 0x0D	; 13
 2de:	82 83       	std	Z+2, r24	; 0x02
 2e0:	8e e0       	ldi	r24, 0x0E	; 14
 2e2:	83 83       	std	Z+3, r24	; 0x03
 2e4:	08 95       	ret

000002e6 <display_volts>:


void display_volts (u16 adval){

//this is will display the voltage.
adval /= 10;		//drop to x.yz volts.  will allow me to use the bottom of the colon as decimal place 
 2e6:	2a e0       	ldi	r18, 0x0A	; 10
 2e8:	30 e0       	ldi	r19, 0x00	; 0
 2ea:	b9 01       	movw	r22, r18
 2ec:	0e 94 ab 02 	call	0x556	; 0x556 <__udivmodhi4>
 2f0:	cb 01       	movw	r24, r22
	digits[0] = adval % 10;
 2f2:	ed e1       	ldi	r30, 0x1D	; 29
 2f4:	f1 e0       	ldi	r31, 0x01	; 1
 2f6:	b9 01       	movw	r22, r18
 2f8:	0e 94 ab 02 	call	0x556	; 0x556 <__udivmodhi4>
 2fc:	80 83       	st	Z, r24
	adval /= 10;
	digits [1] = adval %10;
 2fe:	cb 01       	movw	r24, r22
 300:	b9 01       	movw	r22, r18
 302:	0e 94 ab 02 	call	0x556	; 0x556 <__udivmodhi4>
 306:	81 83       	std	Z+1, r24	; 0x01
	adval /= 10;
	digits [2] = adval %10;
 308:	cb 01       	movw	r24, r22
 30a:	b9 01       	movw	r22, r18
 30c:	0e 94 ab 02 	call	0x556	; 0x556 <__udivmodhi4>
 310:	82 83       	std	Z+2, r24	; 0x02
	digits [3] = 10;	//10 is all off
 312:	8a e0       	ldi	r24, 0x0A	; 10
 314:	83 83       	std	Z+3, r24	; 0x03
 316:	08 95       	ret

00000318 <display_intensity>:
}

//while clockstat == intenset, this will be called once a second.  Will increment teh intensity from 1-9 and display it.
void display_intensity (void) {
    intensity ++;
 318:	80 91 19 01 	lds	r24, 0x0119
 31c:	8f 5f       	subi	r24, 0xFF	; 255
    if(intensity == 10){intensity = 1;}
 31e:	8a 30       	cpi	r24, 0x0A	; 10
 320:	09 f4       	brne	.+2      	; 0x324 <display_intensity+0xc>
 322:	81 e0       	ldi	r24, 0x01	; 1
 324:	80 93 19 01 	sts	0x0119, r24
    for (int i = 0; i < 4; i ++){
        digits[i] = intensity;
 328:	80 91 19 01 	lds	r24, 0x0119
 32c:	80 93 1d 01 	sts	0x011D, r24
 330:	80 93 1e 01 	sts	0x011E, r24
 334:	80 93 1f 01 	sts	0x011F, r24
 338:	80 93 20 01 	sts	0x0120, r24
 33c:	08 95       	ret

0000033e <__vector_14>:
 33e:	1f 92       	push	r1
 340:	0f 92       	push	r0
 342:	0f b6       	in	r0, 0x3f	; 63
 344:	0f 92       	push	r0
 346:	11 24       	eor	r1, r1
 348:	0f 93       	push	r16
 34a:	1f 93       	push	r17
 34c:	2f 93       	push	r18
 34e:	3f 93       	push	r19
 350:	4f 93       	push	r20
 352:	5f 93       	push	r21
 354:	6f 93       	push	r22
 356:	7f 93       	push	r23
 358:	8f 93       	push	r24
 35a:	9f 93       	push	r25
 35c:	af 93       	push	r26
 35e:	bf 93       	push	r27
 360:	cf 93       	push	r28
 362:	ef 93       	push	r30
 364:	ff 93       	push	r31
 366:	c3 b1       	in	r28, 0x03	; 3
 368:	c1 70       	andi	r28, 0x01	; 1
 36a:	c0 93 1c 01 	sts	0x011C, r28
 36e:	20 91 1b 01 	lds	r18, 0x011B
 372:	c2 13       	cpse	r28, r18
 374:	0a c0       	rjmp	.+20     	; 0x38a <__vector_14+0x4c>
 376:	80 91 17 01 	lds	r24, 0x0117
 37a:	90 91 18 01 	lds	r25, 0x0118
 37e:	01 96       	adiw	r24, 0x01	; 1
 380:	90 93 18 01 	sts	0x0118, r25
 384:	80 93 17 01 	sts	0x0117, r24
 388:	04 c0       	rjmp	.+8      	; 0x392 <__vector_14+0x54>
 38a:	10 92 18 01 	sts	0x0118, r1
 38e:	10 92 17 01 	sts	0x0117, r1
 392:	00 91 17 01 	lds	r16, 0x0117
 396:	10 91 18 01 	lds	r17, 0x0118
 39a:	03 33       	cpi	r16, 0x33	; 51
 39c:	11 05       	cpc	r17, r1
 39e:	58 f0       	brcs	.+22     	; 0x3b6 <__vector_14+0x78>
 3a0:	22 23       	and	r18, r18
 3a2:	49 f0       	breq	.+18     	; 0x3b6 <__vector_14+0x78>
 3a4:	80 91 00 01 	lds	r24, 0x0100
 3a8:	88 23       	and	r24, r24
 3aa:	29 f0       	breq	.+10     	; 0x3b6 <__vector_14+0x78>
 3ac:	81 e0       	ldi	r24, 0x01	; 1
 3ae:	80 93 1a 01 	sts	0x011A, r24
 3b2:	80 93 01 01 	sts	0x0101, r24
 3b6:	80 91 1a 01 	lds	r24, 0x011A
 3ba:	88 23       	and	r24, r24
 3bc:	41 f0       	breq	.+16     	; 0x3ce <__vector_14+0x90>
 3be:	c1 11       	cpse	r28, r1
 3c0:	06 c0       	rjmp	.+12     	; 0x3ce <__vector_14+0x90>
 3c2:	10 92 1a 01 	sts	0x011A, r1
 3c6:	0e 94 32 01 	call	0x264	; 0x264 <timeequals0>
 3ca:	10 92 01 01 	sts	0x0101, r1
 3ce:	80 91 00 01 	lds	r24, 0x0100
 3d2:	88 23       	and	r24, r24
 3d4:	81 f0       	breq	.+32     	; 0x3f6 <__vector_14+0xb8>
 3d6:	c1 11       	cpse	r28, r1
 3d8:	0e c0       	rjmp	.+28     	; 0x3f6 <__vector_14+0xb8>
 3da:	00 31       	cpi	r16, 0x10	; 16
 3dc:	17 42       	sbci	r17, 0x27	; 39
 3de:	58 f0       	brcs	.+22     	; 0x3f6 <__vector_14+0xb8>
 3e0:	10 92 16 01 	sts	0x0116, r1
 3e4:	10 92 15 01 	sts	0x0115, r1
 3e8:	0e 94 68 01 	call	0x2d0	; 0x2d0 <display_batt>
 3ec:	82 e0       	ldi	r24, 0x02	; 2
 3ee:	80 93 01 01 	sts	0x0101, r24
 3f2:	10 92 00 01 	sts	0x0100, r1
 3f6:	80 91 01 01 	lds	r24, 0x0101
 3fa:	84 30       	cpi	r24, 0x04	; 4
 3fc:	69 f4       	brne	.+26     	; 0x418 <__vector_14+0xda>
 3fe:	cc 23       	and	r28, r28
 400:	59 f0       	breq	.+22     	; 0x418 <__vector_14+0xda>
 402:	80 91 19 01 	lds	r24, 0x0119
 406:	0e 94 8c 00 	call	0x118	; 0x118 <set_intensity>
 40a:	0e 94 32 01 	call	0x264	; 0x264 <timeequals0>
 40e:	81 e0       	ldi	r24, 0x01	; 1
 410:	80 93 00 01 	sts	0x0100, r24
 414:	80 93 01 01 	sts	0x0101, r24
 418:	80 91 1c 01 	lds	r24, 0x011C
 41c:	80 93 1b 01 	sts	0x011B, r24
 420:	80 91 14 01 	lds	r24, 0x0114
 424:	8f 5f       	subi	r24, 0xFF	; 255
 426:	80 93 14 01 	sts	0x0114, r24
 42a:	90 91 19 01 	lds	r25, 0x0119
 42e:	89 17       	cp	r24, r25
 430:	18 f0       	brcs	.+6      	; 0x438 <__vector_14+0xfa>
 432:	88 b1       	in	r24, 0x08	; 8
 434:	8f 60       	ori	r24, 0x0F	; 15
 436:	88 b9       	out	0x08, r24	; 8
 438:	80 91 14 01 	lds	r24, 0x0114
 43c:	8a 30       	cpi	r24, 0x0A	; 10
 43e:	68 f0       	brcs	.+26     	; 0x45a <__vector_14+0x11c>
 440:	0e 94 be 00 	call	0x17c	; 0x17c <next_digit>
 444:	10 92 14 01 	sts	0x0114, r1
 448:	80 91 15 01 	lds	r24, 0x0115
 44c:	90 91 16 01 	lds	r25, 0x0116
 450:	01 96       	adiw	r24, 0x01	; 1
 452:	90 93 16 01 	sts	0x0116, r25
 456:	80 93 15 01 	sts	0x0115, r24
 45a:	80 91 15 01 	lds	r24, 0x0115
 45e:	90 91 16 01 	lds	r25, 0x0116
 462:	84 3f       	cpi	r24, 0xF4	; 244
 464:	91 40       	sbci	r25, 0x01	; 1
 466:	80 f1       	brcs	.+96     	; 0x4c8 <__vector_14+0x18a>
 468:	80 91 01 01 	lds	r24, 0x0101
 46c:	82 30       	cpi	r24, 0x02	; 2
 46e:	69 f0       	breq	.+26     	; 0x48a <__vector_14+0x14c>
 470:	28 f4       	brcc	.+10     	; 0x47c <__vector_14+0x13e>
 472:	81 30       	cpi	r24, 0x01	; 1
 474:	29 f5       	brne	.+74     	; 0x4c0 <__vector_14+0x182>
 476:	0e 94 03 01 	call	0x206	; 0x206 <inc_seconds>
 47a:	22 c0       	rjmp	.+68     	; 0x4c0 <__vector_14+0x182>
 47c:	83 30       	cpi	r24, 0x03	; 3
 47e:	59 f0       	breq	.+22     	; 0x496 <__vector_14+0x158>
 480:	84 30       	cpi	r24, 0x04	; 4
 482:	f1 f4       	brne	.+60     	; 0x4c0 <__vector_14+0x182>
 484:	0e 94 8c 01 	call	0x318	; 0x318 <display_intensity>
 488:	1b c0       	rjmp	.+54     	; 0x4c0 <__vector_14+0x182>
 48a:	0e 94 5a 00 	call	0xb4	; 0xb4 <read_ADC>
 48e:	0e 94 73 01 	call	0x2e6	; 0x2e6 <display_volts>
 492:	83 e0       	ldi	r24, 0x03	; 3
 494:	13 c0       	rjmp	.+38     	; 0x4bc <__vector_14+0x17e>
 496:	20 91 1c 01 	lds	r18, 0x011C
 49a:	80 91 17 01 	lds	r24, 0x0117
 49e:	90 91 18 01 	lds	r25, 0x0118
 4a2:	22 23       	and	r18, r18
 4a4:	39 f0       	breq	.+14     	; 0x4b4 <__vector_14+0x176>
 4a6:	80 31       	cpi	r24, 0x10	; 16
 4a8:	97 42       	sbci	r25, 0x27	; 39
 4aa:	50 f0       	brcs	.+20     	; 0x4c0 <__vector_14+0x182>
 4ac:	81 e0       	ldi	r24, 0x01	; 1
 4ae:	0e 94 ac 00 	call	0x158	; 0x158 <setsleepstat>
 4b2:	06 c0       	rjmp	.+12     	; 0x4c0 <__vector_14+0x182>
 4b4:	80 32       	cpi	r24, 0x20	; 32
 4b6:	9e 44       	sbci	r25, 0x4E	; 78
 4b8:	18 f0       	brcs	.+6      	; 0x4c0 <__vector_14+0x182>
 4ba:	84 e0       	ldi	r24, 0x04	; 4
 4bc:	80 93 01 01 	sts	0x0101, r24
 4c0:	10 92 16 01 	sts	0x0116, r1
 4c4:	10 92 15 01 	sts	0x0115, r1
 4c8:	ff 91       	pop	r31
 4ca:	ef 91       	pop	r30
 4cc:	cf 91       	pop	r28
 4ce:	bf 91       	pop	r27
 4d0:	af 91       	pop	r26
 4d2:	9f 91       	pop	r25
 4d4:	8f 91       	pop	r24
 4d6:	7f 91       	pop	r23
 4d8:	6f 91       	pop	r22
 4da:	5f 91       	pop	r21
 4dc:	4f 91       	pop	r20
 4de:	3f 91       	pop	r19
 4e0:	2f 91       	pop	r18
 4e2:	1f 91       	pop	r17
 4e4:	0f 91       	pop	r16
 4e6:	0f 90       	pop	r0
 4e8:	0f be       	out	0x3f, r0	; 63
 4ea:	0f 90       	pop	r0
 4ec:	1f 90       	pop	r1
 4ee:	18 95       	reti

000004f0 <main>:


int main(void)
{ 
	
DDRD = 0xFF;	//portD drives the digits of the 7-segment display
 4f0:	8f ef       	ldi	r24, 0xFF	; 255
 4f2:	8a b9       	out	0x0a, r24	; 10
PORTD = 0;		//initially kill output
 4f4:	1b b8       	out	0x0b, r1	; 11
DDRC = 0x1F;	//PC4 = divider_control, PC0-3 = pass p-fets for digits
 4f6:	8f e1       	ldi	r24, 0x1F	; 31
 4f8:	87 b9       	out	0x07, r24	; 7
PORTC = 0;
 4fa:	18 b8       	out	0x08, r1	; 8
DDRB = 0xEE;	//PB0 = button_in, PB1 = TP1
 4fc:	8e ee       	ldi	r24, 0xEE	; 238
 4fe:	84 b9       	out	0x04, r24	; 4
PORTB = 0;		//all off.	
 500:	15 b8       	out	0x05, r1	; 5
PCMSK0 |= 0x01;	//unmask PCINT0 which is the button.
 502:	80 91 6b 00 	lds	r24, 0x006B
 506:	81 60       	ori	r24, 0x01	; 1
 508:	80 93 6b 00 	sts	0x006B, r24
initialize_intensity (get_intensity());
 50c:	0e 94 91 00 	call	0x122	; 0x122 <get_intensity>
 510:	0e 94 bb 00 	call	0x176	; 0x176 <initialize_intensity>
timer0Init();
 514:	0e 94 af 00 	call	0x15e	; 0x15e <timer0Init>
init_ADC();
 518:	0e 94 53 00 	call	0xa6	; 0xa6 <init_ADC>
sei();	
 51c:	78 94       	sei
set_sleep_mode(SLEEP_MODE_IDLE);
 51e:	83 b7       	in	r24, 0x33	; 51
 520:	81 7f       	andi	r24, 0xF1	; 241
 522:	83 bf       	out	0x33, r24	; 51
	
	
  
    while (1) 
    {
	sleep_mode();	
 524:	83 b7       	in	r24, 0x33	; 51
 526:	81 60       	ori	r24, 0x01	; 1
 528:	83 bf       	out	0x33, r24	; 51
 52a:	88 95       	sleep
 52c:	83 b7       	in	r24, 0x33	; 51
 52e:	8e 7f       	andi	r24, 0xFE	; 254
 530:	83 bf       	out	0x33, r24	; 51
		if(gotosleep){	//go to sleep is a flag that gets set wehn it's time to go to sleep.  
 532:	80 91 12 01 	lds	r24, 0x0112
 536:	88 23       	and	r24, r24
 538:	a9 f3       	breq	.-22     	; 0x524 <main+0x34>
			shut_r_down();
 53a:	0e 94 39 01 	call	0x272	; 0x272 <shut_r_down>
 53e:	f2 cf       	rjmp	.-28     	; 0x524 <main+0x34>

00000540 <__muluhisi3>:
 540:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <__umulhisi3>
 544:	a5 9f       	mul	r26, r21
 546:	90 0d       	add	r25, r0
 548:	b4 9f       	mul	r27, r20
 54a:	90 0d       	add	r25, r0
 54c:	a4 9f       	mul	r26, r20
 54e:	80 0d       	add	r24, r0
 550:	91 1d       	adc	r25, r1
 552:	11 24       	eor	r1, r1
 554:	08 95       	ret

00000556 <__udivmodhi4>:
 556:	aa 1b       	sub	r26, r26
 558:	bb 1b       	sub	r27, r27
 55a:	51 e1       	ldi	r21, 0x11	; 17
 55c:	07 c0       	rjmp	.+14     	; 0x56c <__udivmodhi4_ep>

0000055e <__udivmodhi4_loop>:
 55e:	aa 1f       	adc	r26, r26
 560:	bb 1f       	adc	r27, r27
 562:	a6 17       	cp	r26, r22
 564:	b7 07       	cpc	r27, r23
 566:	10 f0       	brcs	.+4      	; 0x56c <__udivmodhi4_ep>
 568:	a6 1b       	sub	r26, r22
 56a:	b7 0b       	sbc	r27, r23

0000056c <__udivmodhi4_ep>:
 56c:	88 1f       	adc	r24, r24
 56e:	99 1f       	adc	r25, r25
 570:	5a 95       	dec	r21
 572:	a9 f7       	brne	.-22     	; 0x55e <__udivmodhi4_loop>
 574:	80 95       	com	r24
 576:	90 95       	com	r25
 578:	bc 01       	movw	r22, r24
 57a:	cd 01       	movw	r24, r26
 57c:	08 95       	ret

0000057e <__udivmodsi4>:
 57e:	a1 e2       	ldi	r26, 0x21	; 33
 580:	1a 2e       	mov	r1, r26
 582:	aa 1b       	sub	r26, r26
 584:	bb 1b       	sub	r27, r27
 586:	fd 01       	movw	r30, r26
 588:	0d c0       	rjmp	.+26     	; 0x5a4 <__udivmodsi4_ep>

0000058a <__udivmodsi4_loop>:
 58a:	aa 1f       	adc	r26, r26
 58c:	bb 1f       	adc	r27, r27
 58e:	ee 1f       	adc	r30, r30
 590:	ff 1f       	adc	r31, r31
 592:	a2 17       	cp	r26, r18
 594:	b3 07       	cpc	r27, r19
 596:	e4 07       	cpc	r30, r20
 598:	f5 07       	cpc	r31, r21
 59a:	20 f0       	brcs	.+8      	; 0x5a4 <__udivmodsi4_ep>
 59c:	a2 1b       	sub	r26, r18
 59e:	b3 0b       	sbc	r27, r19
 5a0:	e4 0b       	sbc	r30, r20
 5a2:	f5 0b       	sbc	r31, r21

000005a4 <__udivmodsi4_ep>:
 5a4:	66 1f       	adc	r22, r22
 5a6:	77 1f       	adc	r23, r23
 5a8:	88 1f       	adc	r24, r24
 5aa:	99 1f       	adc	r25, r25
 5ac:	1a 94       	dec	r1
 5ae:	69 f7       	brne	.-38     	; 0x58a <__udivmodsi4_loop>
 5b0:	60 95       	com	r22
 5b2:	70 95       	com	r23
 5b4:	80 95       	com	r24
 5b6:	90 95       	com	r25
 5b8:	9b 01       	movw	r18, r22
 5ba:	ac 01       	movw	r20, r24
 5bc:	bd 01       	movw	r22, r26
 5be:	cf 01       	movw	r24, r30
 5c0:	08 95       	ret

000005c2 <__umulhisi3>:
 5c2:	a2 9f       	mul	r26, r18
 5c4:	b0 01       	movw	r22, r0
 5c6:	b3 9f       	mul	r27, r19
 5c8:	c0 01       	movw	r24, r0
 5ca:	a3 9f       	mul	r26, r19
 5cc:	70 0d       	add	r23, r0
 5ce:	81 1d       	adc	r24, r1
 5d0:	11 24       	eor	r1, r1
 5d2:	91 1d       	adc	r25, r1
 5d4:	b2 9f       	mul	r27, r18
 5d6:	70 0d       	add	r23, r0
 5d8:	81 1d       	adc	r24, r1
 5da:	11 24       	eor	r1, r1
 5dc:	91 1d       	adc	r25, r1
 5de:	08 95       	ret

000005e0 <__eerd_byte_m328p>:
 5e0:	f9 99       	sbic	0x1f, 1	; 31
 5e2:	fe cf       	rjmp	.-4      	; 0x5e0 <__eerd_byte_m328p>
 5e4:	92 bd       	out	0x22, r25	; 34
 5e6:	81 bd       	out	0x21, r24	; 33
 5e8:	f8 9a       	sbi	0x1f, 0	; 31
 5ea:	99 27       	eor	r25, r25
 5ec:	80 b5       	in	r24, 0x20	; 32
 5ee:	08 95       	ret

000005f0 <__eewr_byte_m328p>:
 5f0:	26 2f       	mov	r18, r22

000005f2 <__eewr_r18_m328p>:
 5f2:	f9 99       	sbic	0x1f, 1	; 31
 5f4:	fe cf       	rjmp	.-4      	; 0x5f2 <__eewr_r18_m328p>
 5f6:	1f ba       	out	0x1f, r1	; 31
 5f8:	92 bd       	out	0x22, r25	; 34
 5fa:	81 bd       	out	0x21, r24	; 33
 5fc:	20 bd       	out	0x20, r18	; 32
 5fe:	0f b6       	in	r0, 0x3f	; 63
 600:	f8 94       	cli
 602:	fa 9a       	sbi	0x1f, 2	; 31
 604:	f9 9a       	sbi	0x1f, 1	; 31
 606:	0f be       	out	0x3f, r0	; 63
 608:	01 96       	adiw	r24, 0x01	; 1
 60a:	08 95       	ret

0000060c <_exit>:
 60c:	f8 94       	cli

0000060e <__stop_program>:
 60e:	ff cf       	rjmp	.-2      	; 0x60e <__stop_program>
